import os
from typing import List, Tuple
from uuid import uuid4

import joblib
import numpy as np
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.pipeline import FeatureUnion
from sklearn.preprocessing import FunctionTransformer

from app.core.config import settings


PROFILE = settings.resolve_profile(None)
MODEL_PATH = os.path.join(settings.models_dir, f"malware_{PROFILE}.joblib")


def _join_list_feature(X: List[List[str]]) -> List[str]:
    out: List[str] = []
    for v in X:
        if v is None:
            out.append("")
            continue
        # Ensure we handle numpy arrays and lists uniformly without truth-value checks
        if isinstance(v, (list, tuple, np.ndarray)):
            try:
                seq = list(v)
            except Exception:
                seq = []
            out.append(" ".join(str(x) for x in seq))
        else:
            out.append(str(v))
    return out


def _extract_perms(X):
    return np.array([x.get("permissions", []) for x in X], dtype=object)


def _extract_api(X):
    return np.array([x.get("api_calls", []) for x in X], dtype=object)


def _extract_behaviors(X):
    return np.array([x.get("behaviors", []) for x in X], dtype=object)


def _build_pipeline(profile: str):
    max_features = 200 if profile == "lite" else 800
    perms_pipe = (
        ("perm_extract", FunctionTransformer(_extract_perms, validate=False)),
        ("perm_join", FunctionTransformer(_join_list_feature, validate=False)),
        ("perm_vec", TfidfVectorizer(min_df=1, max_features=max_features))
    )
    api_pipe = (
        ("api_extract", FunctionTransformer(_extract_api, validate=False)),
        ("api_join", FunctionTransformer(_join_list_feature, validate=False)),
        ("api_vec", TfidfVectorizer(min_df=1, max_features=max_features))
    )
    beh_pipe = (
        ("beh_extract", FunctionTransformer(_extract_behaviors, validate=False)),
        ("beh_join", FunctionTransformer(_join_list_feature, validate=False)),
        ("beh_vec", TfidfVectorizer(min_df=1, max_features=max_features))
    )

    union = FeatureUnion([
        ("perms", make_pipeline(*perms_pipe)),
        ("api", make_pipeline(*api_pipe)),
        ("beh", make_pipeline(*beh_pipe)),
    ])
    if profile == "lite":
        from sklearn.naive_bayes import MultinomialNB

        clf = MultinomialNB(alpha=0.8)
    else:
        from sklearn.ensemble import RandomForestClassifier

        clf = RandomForestClassifier(n_estimators=60, max_depth=12, random_state=42)
    return make_pipeline(union, clf)


def make_pipeline(*steps):
    from sklearn.pipeline import Pipeline
    return Pipeline(steps=steps)


class MalwareService:
    def __init__(self) -> None:
        self.model = None
        self.labels = ["safe", "suspicious", "malicious"]
        self.profile = PROFILE
        self.algorithm = "MultinomialNB" if self.profile == "lite" else "RandomForest"
        self._ensure_model()

    def _ensure_model(self):
        if os.path.exists(MODEL_PATH):
            self.model = joblib.load(MODEL_PATH)
            return

        # Train a tiny placeholder model on synthetic data for demo purposes
        self.model = _build_pipeline(self.profile)
        X = [
            {"permissions": ["INTERNET", "ACCESS_WIFI_STATE"], "api_calls": ["okhttp", "retrofit"], "behaviors": ["net"]},
            {"permissions": ["READ_SMS", "RECEIVE_SMS"], "api_calls": ["sendTextMessage"], "behaviors": ["sms"]},
            {"permissions": ["READ_CONTACTS", "WRITE_CONTACTS"], "api_calls": ["contactsProvider"], "behaviors": ["data_exfil"]},
            {"permissions": ["SYSTEM_ALERT_WINDOW"], "api_calls": ["exec"], "behaviors": ["root", "overlay"]},
        ]
        y = [0, 2, 1, 2]  # simple labels
        self.model.fit(X, y)
        joblib.dump(self.model, MODEL_PATH)

    def predict(self, features: dict) -> Tuple[str, float]:
        proba = self.model.predict_proba([features])[0]
        idx = int(np.argmax(proba))
        return self.labels[idx], float(proba[idx])

    def new_scan_id(self) -> str:
        return f"apk_{uuid4()}"

    def info(self) -> dict:
        return {
            "name": "malware",
            "algorithm": self.algorithm,
            "profile": self.profile,
            "model_path": MODEL_PATH,
        }


malware_service = MalwareService()
